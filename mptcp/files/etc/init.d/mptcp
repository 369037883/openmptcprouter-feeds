#!/bin/sh /etc/rc.common

START=18

USE_PROCD=1

global_multipath_settings() {
	local multipath mptcp_path_manager mptcp_schdeduler congestion
	local multipath_status=0
	config_load network
	config_get multipath globals multipath
	config_get mptcp_path_manager globals mptcp_path_manager
	config_get mptcp_scheduler globals mptcp_scheduler
	config_get congestion globals congestion
	[ "$multipath" = "enable" ] && multipath_status=1

	# Global MPTCP configuration
	sysctl -qw net.mptcp.mptcp_enabled="$multipath_status"
	[ -z "$mptcp_path_manager" ] || sysctl -qw net.mptcp.mptcp_path_manager="$mptcp_path_manager"
	[ -z "$mptcp_scheduler" ] || sysctl -qw net.mptcp.mptcp_scheduler="$mptcp_scheduler"
	[ -z "$congestion" ] || sysctl -qw net.ipv4.tcp_congestion_control="$congestion"
}

interface_multipath_settings() {
	local mode iface
	local config="$1"
	local intf="$2"

	config_get iface "$config" ifname
	count=$(($count+1))
	id=$count
	[ -n "$intf" ] && [ "$iface" != "$intf" ] && return 0
	[ -z "$iface" ] && return 0
	[ -n "$(ifconfig | grep $iface)" ] || return 0
	config_get mode "$config" multipath "off"
	[ "$mode" = "off" ] && {
		ip rule del table $id > /dev/null 2>&1
		ip route flush $id > /dev/null 2>&1
		return 1
	}

	[ "$mode" = "master" ] && mode="on"
	multipath "$iface" "$mode"

	# IPv4 Updates:
	local ipaddr
	local gateway
	local network
	local netmask
	local proto
	config_get proto $config proto
	if [ "$proto" = "static" ]; then
		config_get ipaddr $config ipaddr
		config_get gateway $config gateway
		config_get netmask $config netmask
		network=`ipcalc.sh $ipaddr $netmask | sed -n '/NETWORK=/{;s/.*=//;s/ .*//;p;}'`
	else
		network_get_ipaddr $config ipaddr
		ipaddr=$(ip -4 addr show dev $iface | grep inet | awk '{print $2}' | cut -d/ -f1 | tr -d "\n")
		gateway=$(ip -4 r list dev $iface | grep -v default | awk '/proto static/ {print $1}' | tr -d "\n")
		[ -z "$gateway" ] && gateway=$(uci -q get "network.$config.gateway")
		[ -z "$gateway" ] && gateway=$(ubus call network.interface.$config status | jsonfilter -e '@.route[0].nexthop' | tr -d "\n")
		[ -z "$gateway" ] && gateway=$(ubus call network.interface.$config status | jsonfilter -e '@.inactive.route[0].nexthop' | tr -d "\n")
		netmask=$(ip -4 addr show dev $iface | grep inet | awk '{print $2}' | cut -d/ -f2 | tr -d "\n")
		network=`ipcalc.sh $ipaddr $netmask | sed -n '/NETWORK=/{;s/.*=//;s/ .*//;p;}'`
	fi
	ip rule del table $id > /dev/null 2>&1
	ip route flush $id > /dev/null 2>&1
	[ -n "$gateway" ] || return 1
	ip rule add from $ipaddr table $id
	ip route replace $network/$netmask dev $iface scope link table $id
	ip route replace default via $gateway dev $iface table $id
	ip route flush $id

	config_get mode "$config" multipath "off"
	[ "$mode" = "master" ] && {
		ip route replace default via $gateway dev $iface
	}
}

load_interfaces() {
	config_get ifname "$1" ifname
	config_get multipath "$1" multipath "off"
	[ "$multipath" != "off" ] && interface=" ${ifname} ${interfaces}"
}

start_service() {
	local intf=$1
	local id count
	. /lib/functions.sh
	. /lib/functions/network.sh
	global_multipath_settings
	config_load network
	config_foreach interface_multipath_settings interface $intf
}

reload_service() {
	rc_procd start_service "$@"
	return 0
}

service_triggers() {
	local interfaces
	procd_add_reload_trigger network
	config_load network
	config_foreach load_interfaces interface

	[ -n "${interfaces}" ] && {
		for n in $interfaces ; do
			procd_add_interface_trigger "interface.*" $n /etc/init.d/mptcp reload $n
		done
	}
}
